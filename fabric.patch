Only in ../fabric/: .git
Only in ../fabric/: build
diff -ru ./fabric/common/ledger/blkstorage/block_serialization.go ../fabric/common/ledger/blkstorage/block_serialization.go
--- ./fabric/common/ledger/blkstorage/block_serialization.go	2022-01-28 10:57:00.000000000 +0800
+++ ../fabric/common/ledger/blkstorage/block_serialization.go	2022-09-14 14:06:16.000000000 +0800
@@ -89,6 +89,12 @@
 	if err := buf.EncodeRawBytes(blockHeader.PreviousHash); err != nil {
 		return errors.Wrapf(err, "error encoding the previous hash [%v]", blockHeader.PreviousHash)
 	}
+	//////////////////////////////////////////////////////////////////////////////////////////////////
+	// added by fjyu@whu.edu.cn at 2022.09.14
+        if err := buf.EncodeRawBytes(blockHeader.MMRRoot); err != nil {
+                return errors.Wrapf(err, "error encoding the MMRRoot [%v]", blockHeader.MMRRoot)
+        }	
+	//////////////////////////////////////////////////////////////////////////////////////////////////
 	return nil
 }
 
@@ -142,6 +148,12 @@
 	if header.PreviousHash, err = buf.DecodeRawBytes(false); err != nil {
 		return nil, errors.Wrap(err, "error decoding the previous hash")
 	}
+	//////////////////////////////////////////////////////////////////////////////////////////////////
+	// added by fjyu@whu.edu.cn at 2022.09.14
+        if header.MMRRoot, err = buf.DecodeRawBytes(false); err != nil {
+               return nil, errors.Wrap(err, "error decoding the MMRRoot")
+        }	
+	//////////////////////////////////////////////////////////////////////////////////////////////////
 	if len(header.PreviousHash) == 0 {
 		header.PreviousHash = nil
 	}
@@ -167,7 +179,6 @@
 		if txid, err = protoutil.GetOrComputeTxIDFromEnvelope(txEnvBytes); err != nil {
 			logger.Warningf("error while extracting txid from tx envelope bytes during deserialization of block. Ignoring this error as this is caused by a malformed transaction. Error:%s",
 				err)
-
 		}
 		data.Data = append(data.Data, txEnvBytes)
 		idxInfo := &txindexInfo{txID: txid, loc: &locPointer{txOffset, buf.GetBytesConsumed() - txOffset}}
Only in ../fabric/common/ledger/blkstorage: block_serialization.go.backup
Only in ../fabric/core/chaincode/platforms/golang/testdata: pkg
diff -ru ./fabric/go.mod ../fabric/go.mod
--- ./fabric/go.mod	2022-01-28 10:57:00.000000000 +0800
+++ ../fabric/go.mod	2022-09-29 16:10:19.000000000 +0800
@@ -43,6 +43,7 @@
 	github.com/kr/pretty v0.2.0
 	github.com/magiconair/properties v1.8.1 // indirect
 	github.com/mattn/go-runewidth v0.0.4 // indirect
+	github.com/mattn/go-sqlite3 v1.14.15
 	github.com/miekg/pkcs11 v1.0.3
 	github.com/mitchellh/mapstructure v1.2.2
 	github.com/onsi/ginkgo v1.14.0
diff -ru ./fabric/go.sum ../fabric/go.sum
--- ./fabric/go.sum	2022-01-28 10:57:00.000000000 +0800
+++ ../fabric/go.sum	2022-09-29 16:10:19.000000000 +0800
@@ -170,6 +170,8 @@
 github.com/mattn/go-runewidth v0.0.2/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=
 github.com/mattn/go-runewidth v0.0.4 h1:2BvfKmzob6Bmd4YsL0zygOqfdFnK7GR4QL06Do4/p7Y=
 github.com/mattn/go-runewidth v0.0.4/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=
+github.com/mattn/go-sqlite3 v1.14.15 h1:vfoHhTN1af61xCRSWzFIWzx2YskyMTwHLrExkBOjvxI=
+github.com/mattn/go-sqlite3 v1.14.15/go.mod h1:2eHXhiwb8IkHr+BDWZGa96P6+rkvnG63S2DGjv9HUNg=
 github.com/matttproud/golang_protobuf_extensions v1.0.0/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
 github.com/matttproud/golang_protobuf_extensions v1.0.1 h1:4hp9jkHxhMHkqkrB3Ix0jegS5sx/RkqARlsWZ6pIwiU=
 github.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
diff -ru ./fabric/protoutil/blockutils.go ../fabric/protoutil/blockutils.go
--- ./fabric/protoutil/blockutils.go	2022-01-28 10:57:00.000000000 +0800
+++ ../fabric/protoutil/blockutils.go	2022-10-27 17:43:04.000000000 +0800
@@ -15,8 +15,639 @@
 	"github.com/golang/protobuf/proto"
 	cb "github.com/hyperledger/fabric-protos-go/common"
 	"github.com/pkg/errors"
+
+	////////////////////////////////////////////////////
+	// added by fjyu@whu.edu.cn at 2022.09.29
+        // "crypto/sha256"
+        "database/sql"
+        "encoding/hex"
+        "fmt"
+        _"github.com/mattn/go-sqlite3"
+        "math"
+        "os"
+        "sort"
+	"strings"
+	////////////////////////////////////////////////////
 )
 
+
+////////////////////////////////////////////////////
+// added by fjyu@whu.edu.cn at 2022.09.29
+
+// 打开数据库 		mmr:=MMR.Open("./test.db")
+// 删除文件			MMR.Remove("./test.db")
+// 插入数据			root:=mmr.Newnode(hashvalue,blockindex) 区块号从0开始编号
+
+type any interface{}
+var blockroot [][]byte
+
+func hash256(arg ...[]byte) []byte {
+	m := sha256.New()
+	for _, value := range arg {
+		m.Write(value)
+	}
+	return m.Sum(nil)
+}
+
+type Node struct {
+	hashValue []byte
+	height    uint64
+	id        uint64
+}
+
+type MMR struct {
+	//nodeList [] Node
+	//blockList [] Block
+	db      *sql.DB
+	peaks   []uint64
+	root    []byte
+	nodeNum uint64
+}
+
+// 打开db，返回一个MMR实例，用该实例进行增加和验证操作
+func OpenMMRDB(dataSource string) MMR {
+	var mmr MMR
+	db, err := sql.Open("sqlite3", dataSource) //若数据库没有在这个项目文件下，则需要写绝对路径
+	checkErr(err)
+	mmr.db = db
+	mmr.creatTable()
+	return mmr
+}
+func CloseMMRDB(mmr *MMR) {
+	mmr.db.Close()
+}
+
+// 删除db
+func RemoveMMRDataBase(file string) {
+	err := os.Remove(file) //删除文件test.txt
+	if err != nil {
+		//如果删除失败则输出 file remove Error!
+		fmt.Println("MMRDataBase file remove Error!")
+		//输出错误详细信息
+		fmt.Printf("%s", err)
+	} else {
+		//如果删除成功则输出 file remove OK!
+		fmt.Println("MMRDataBase file remove OK!")
+	}
+}
+
+// NewNode 增加或者验证节点,传入哈希值和区块号；若添加新的叶子结点，添加后返回根值；若验证旧的结点，返回根据传入哈希生成的根值
+func (mmr *MMR) NewNode(args ...any) any {
+	var hashValue []byte
+	var blockNum uint64
+	// only blockNums
+	if len(args) == 2 {
+		switch args[0].(type) {
+		case []byte:
+			hashValue = args[0].([]byte)
+			break
+		case uint64:
+			blockNum = args[0].(uint64)
+			break
+		default:
+			break
+		} //end switch
+		switch args[1].(type) {
+		case []byte:
+			hashValue = args[1].([]byte)
+			break
+		case uint64:
+			blockNum = args[1].(uint64)
+			break
+		default:
+			break
+		} // end switch
+		return mmr.newNodeorProof(hashValue, blockNum)
+
+	} else {
+		fmt.Println("Parameter error. Check whether it is single(BlockNum(s)) or double(BlockNum and HashValue)")
+	} //end elif
+	return nil
+}
+
+func (mmr *MMR) newNodeorProof(hashValue []byte, index uint64) []byte {
+	// 获取block对应叶子ID
+	pos := index
+	if pos >= 0 {
+		id := Find_mmr_ID_by_block_index(pos).(uint64)
+		// 获取MMR树节点个数
+		maxId := mmr.nodeNum
+		var blockNums []uint64
+		blockNums = append(blockNums, pos)
+		blockHashMap := make(map[uint64][]byte)
+		blockHashMap[pos] = hashValue
+		if id == maxId+1 {
+			//插入新的叶子节点
+			//验证路径
+			// 保存新生节点哈希
+			var newnodes [][]byte
+			if pos == 0 { //第一个，不验证
+				newnodes = append(newnodes, hashValue)
+				mmr.addToDataBase(newnodes)
+				mmr.creatRoot(mmr.nodeNum)
+				blockroot = append(blockroot, mmr.root)
+			} else {
+				proofPath := mmr.GenProofPath(blockNums)
+				//oldroot := mmr.CreatProofRoot(proofPath, nil) //true 是添加叶子
+				if true /*string(oldroot) == string(blockroot[index-1])*/ {
+					var bro uint64
+					for {
+						newnodes = append(newnodes, hashValue)
+						bro = Find_bro_by_ID(id, mmr.nodeNum)
+						if bro != 0 {
+							broHash, flag := proofPath[bro]
+							if flag {
+								hashValue = hash256(broHash, hashValue)
+								id++
+							}
+						} else {
+							break
+						}
+					}
+					//把新生节点加入到数据库
+					mmr.addToDataBase(newnodes)
+					mmr.creatRoot(mmr.nodeNum)
+					blockroot = append(blockroot, mmr.root)
+				} else {
+					fmt.Println("添加叶子路径验证失败")
+				}
+			} // 添加结束
+		} else if id < maxId+1 { //单路验证
+			proofPath := mmr.GenProofPath(blockNums)
+			root := mmr.CreatProofRoot(proofPath, blockHashMap)
+			return root
+		} else {
+			fmt.Println("块号不连续：传入的块号不是当前最大块号的下一个！！！\n", "当前最大块号：", Find_block_index_by_mmr_ID(maxId), " 传入块号：", pos)
+		}
+		return mmr.root
+	} else {
+		fmt.Println("输入序号index错误！")
+		return nil
+	}
+}
+
+// 获取id值并升序排序
+type array []uint64
+
+func (a array) Len() int {
+	return len(a)
+}
+func (a array) Swap(i, j int) {
+	a[i], a[j] = a[j], a[i]
+}
+func (a array) Less(i, j int) bool {
+	return a[i] < a[j]
+}
+func itemSort(m any) []uint64 {
+	var a []uint64
+	switch m.(type) {
+	case map[uint64]uint64:
+		for k, _ := range m.(map[uint64]uint64) {
+			a = append(a, k)
+		}
+		break
+	case map[uint64][]byte:
+		for k, _ := range m.(map[uint64][]byte) {
+			a = append(a, k)
+		}
+		break
+	}
+	sort.Sort(array(a[:]))
+	return a[:]
+}
+
+// 根据index找兄弟;没有兄弟的返回值是0
+func Find_bro_by_ID(id uint64, maxID uint64) uint64 {
+	//MMR树结点个数
+	//maxID:=mmr.nodeNum
+	//id对应结点高度
+	height := GetHeightByID(id)
+	if id > maxID {
+		// id越界，右兄弟一定不存在，只能找找左兄弟
+		id_bro := id - (2 << height) + 1
+		if id_bro >= 0 && height == GetHeightByID(id_bro) {
+			return id_bro
+		}
+		return 0
+	}
+	// 找右兄弟 +2^(h+1)-1
+	id_bro := id + (2 << height) - 1
+	// 满足要求，节点存在，高度一样，找到了右兄弟
+	if id_bro < maxID && height == GetHeightByID(id_bro) {
+		return id_bro
+	}
+	// 否则 找左兄弟
+	id_bro = id - (2 << height) + 1
+	if id_bro >= 0 && height == GetHeightByID(id_bro) {
+		return id_bro
+	}
+	return 0
+}
+
+// 根据id找父节点；没有父节点返回值是-1；
+func Find_parent_by_ID(id uint64, maxID uint64) uint64 {
+	//MMR树结点个数
+	//maxID:=mmr.nodeNum
+	if id > maxID {
+		// id越界，如果它有孤儿兄弟，右上方找它的孤儿父母
+		height := GetHeightByID(id)
+		height_next := GetHeightByID(id + 1)
+		if height < height_next {
+			return id + 1
+		}
+		return 0
+	}
+	//id对应结点高度
+	height := GetHeightByID(id)
+	height_next := GetHeightByID(id + 1)
+	if height < height_next {
+		if id+1 <= maxID {
+			return id + 1
+		}
+	} else {
+		if id+2<<height <= maxID {
+			return id + 2<<height
+		}
+	}
+	return 0
+}
+
+// 找到数据库MMR树的所有山峰，并把山峰id临时保存到mmr.peaks[]中
+func FindPeak(num uint64) []uint64 {
+	//清空旧的山峰数据
+	peaks := make([]uint64, 0, 0)
+	// 所有山峰存入self.peak列表
+	// 由于默克尔山脉由从左到右的多个山构成，每个山都是完美二叉树，单独的叶子结点也是一座山，每座山的结点数量满足N=2^x-1
+	// 因此，只需要将mmr_list的结点数量最大拆分成满足N=2^x-1的几个部分（山），山的数量便是山峰的数量
+	//       /'\
+	//     /\  /\    /'\
+	//    /\/\/\/\  /\ /\  /'\
+	// num 结点总数量
+	// 获取最大2的整数次幂-1;max_global对应整个山脉当前关注的山峰的编号
+	var maxGlobal uint64 = 0
+	for num > 0 {
+		// 获取当前山峰从1开始的结点标号; num+1避免1,3,7,15,31等恰好2^x-1的值被漏掉；
+		maxPart := MaxIntPower2(num+1) - 1
+		// 之前的山已经找到了山峰，关注更低矮的山
+		num -= maxPart
+		maxGlobal += maxPart
+		// 示意图结点从1开始标号，对应的数据库ID从1开始标号
+		peaks = append(peaks, maxGlobal)
+	} //end for
+	return peaks
+}
+
+// 生成root;传入MMR树结点个数
+func (mmr *MMR) creatRoot(num uint64) {
+	// 根root从山峰中合并生成
+	mmr.peaks = FindPeak(num)
+	// 从 右→左 合并所有山峰 直到只剩一个山峰，此时便是根root
+	mmr.root = mmr.bagRightPeaks(0, mmr.peaks)
+}
+
+func (mmr *MMR) GetRoot() []byte {
+	mmr.creatRoot(mmr.nodeNum)
+	return mmr.root
+}
+
+// 打包右边的哈希值
+func (mmr *MMR) bagRightPeaks(pos uint64, peaks []uint64) []byte {
+	var peakshash [][]byte
+
+	// 获取 id>pos的山峰，即右边的山峰
+	for _, id := range peaks {
+		if id > pos {
+			peakshash = append(peakshash, mmr.getHashValueByID(id))
+		}
+	} //end for
+
+	// 从右到左 两两合并 直到剩一个
+	for l := len(peakshash); l > 1; {
+		hashvalue := hash256(peakshash[l-2], peakshash[l-1])
+		// 合并后山峰减少一个
+		l -= 1
+		// 替换新的山峰
+		peakshash[l-1] = hashvalue
+	}
+	if len(peakshash) == 0 {
+		return nil
+	}
+	//fmt.Println("peakshash[0]:",[]byte(peakshash[0]))
+	return peakshash[0]
+}
+
+// 根据ID确定高度
+func GetHeightByID(id uint64) uint64 {
+	for {
+		max_ := MaxIntPower2(id + 1)
+		if id+1 == max_ {
+			return uint64(math.Log2(float64(max_))) - 1
+		}
+		id = id + 1 - max_
+	}
+}
+
+// 小于等于x的最大2的整数次方
+func MaxIntPower2(x uint64) uint64 {
+	x |= x >> 1
+	x |= x >> 2
+	x |= x >> 4
+	x |= x >> 8
+	x |= x >> 16
+	x |= x >> 32
+	return x - (x >> 1)
+}
+func GetMMRTreeHeight(maxID uint64) uint64 {
+	max_ := MaxIntPower2(maxID + 1)
+	return uint64(math.Log2(float64(max_))) - 1
+}
+
+// 根据block_list的index确定对应的Node在数据库的id
+// 例如输入的index=9（从0开始）,这些节点对应叶子，都在mmr的底部，将这些叶子按照2的最大整数次幂划分给一座座山当底座
+// 山是完美二叉树，其叶子个数n0=2^x，总节点个数N=2*n0-1
+func Find_mmr_ID_by_block_index(blockindex any) any {
+	switch blockindex.(type) {
+	case uint64:
+		var index uint64 = blockindex.(uint64)
+		var target uint64 = 1
+		for index > 0 {
+			max_ := MaxIntPower2(index)
+			target += 2*max_ - 1
+			index -= max_
+		}
+		return target
+	case []uint64:
+		results := make(map[uint64]uint64)
+		for _, index := range blockindex.([]uint64) {
+			var target uint64 = 1
+			for index > 0 {
+				max_ := MaxIntPower2(index)
+				target += 2*max_ - 1
+				index -= max_
+			}
+			results[target] = target
+		}
+		return results
+	case map[uint64][]byte:
+		results := make(map[uint64][]byte)
+		for index, hashvalue := range blockindex.(map[uint64][]byte) {
+			var target uint64 = 1
+			for index > 0 {
+				max_ := MaxIntPower2(index)
+				target += 2*max_ - 1
+				index -= max_
+			}
+			results[target] = hashvalue
+		}
+		return results
+	}
+	return nil
+}
+
+// 根据mmr_list的叶子ID 确定 block_list的index
+func Find_block_index_by_mmr_ID(id uint64) uint64 {
+	var target uint64 = 0
+	for id > 0 {
+		max_ := MaxIntPower2(id + 1)
+		target += max_ / 2
+		id = id + 1 - max_
+	}
+	return target - 1
+}
+
+// 数据库访问操作
+// 创建表
+func (mmr *MMR) creatTable() {
+	sqlTable := `
+CREATE TABLE IF NOT EXISTS MMRTREE (
+   "ID" INTEGER PRIMARY KEY AUTOINCREMENT,
+   "HASHVALUE" BLOB NOT NULL
+);`
+	_, err := mmr.db.Exec(sqlTable)
+	checkErr(err)
+	mmr.nodeNum = mmr.getMaxID()
+}
+
+// 增加数据
+func (mmr *MMR) addToDataBase(hashValue [][]byte) {
+	//插入数据
+	stmt, err := mmr.db.Prepare("INSERT INTO MMRTREE(HASHVALUE)  values(?)")
+	checkErr(err)
+	mmr.db.Exec("BEGIN ")
+	for _, item := range hashValue {
+		res, err := stmt.Exec(item)
+		checkErr(err)
+		id, err := res.LastInsertId() //返回新增的id号
+		checkErr(err)
+		_ = id
+		// mmr节点数量加一
+		mmr.nodeNum += 1
+		// 输出最近增加的结点ID
+		fmt.Println("insert one row into db for mmr, ID = ", id, ", hashvalue = ", item)
+	}
+	mmr.db.Exec("COMMIT ")
+
+}
+
+// 获取数据库最大ID，即节点总个数
+func (mmr *MMR) getMaxID() uint64 {
+	rows, err := mmr.db.Query("SELECT ID FROM MMRTREE WHERE id=(SELECT MAX(ID) FROM MMRTREE)")
+	checkErr(err)
+	var id uint64 = 0
+	for rows.Next() {
+		err = rows.Scan(&id)
+		checkErr(err)
+		//fmt.Println("id:",id)
+	}
+	return id
+}
+
+// 通过ID从数据库查询节点哈希值
+func (mmr *MMR) getHashValueByID(id uint64) []byte {
+	rows, err := mmr.db.Query("SELECT HASHVALUE FROM MMRTREE WHERE id=?", id)
+	checkErr(err)
+	var hashValue []byte
+	for rows.Next() {
+		err = rows.Scan(&hashValue)
+		checkErr(err)
+	}
+	return hashValue
+}
+
+// 打印数据库
+func (mmr *MMR) Show() {
+	rows, err := mmr.db.Query("SELECT * FROM MMRTREE ")
+	checkErr(err)
+	for rows.Next() {
+		var s []byte
+		var id int
+		err = rows.Scan(&id, &s)
+		checkErr(err)
+		fmt.Println(id, hex.EncodeToString(s))
+	}
+}
+
+// 错误处理
+func checkErr(err error) {
+	_ = err
+}
+
+// 通过多个ID从数据库查询节点
+func(mmr *MMR) GetHashByID(ids[] uint64) map[uint64][]byte {
+	var hash []byte
+	result := make(map[uint64][]byte)
+	var icount uint64 =0
+	for i:=0;i<len(ids);i+=10000{//不能一次性从数据库取太多
+		//t1:=time.Now()
+		var x []interface{}
+		var end int
+		if len(ids)-10000>i{
+			end=10000
+		}else{
+			end=len(ids)-i
+		}
+		for _,item:=range ids[i:i+end]{
+			x=append(x, item)
+		}
+
+		s:="SELECT HASHVALUE FROM MMRTREE WHERE id in "
+		s+="("
+		s+=strings.Repeat("?,", len(x)-1)
+		s+="?)"
+
+		//t2:=time.Since(t1)
+
+		rows,err:=mmr.db.Query(s,x...)
+		//t3:=time.Since(t1)
+		//fmt.Println(t2,t3)
+		if err!=nil{
+			fmt.Println("err:",err)
+			os.Exit(0)
+		}
+		for rows.Next() {
+			err = rows.Scan(&hash)
+			checkErr(err)
+			t := ids[icount]
+			icount++
+			result[t] = hash
+		}
+	}
+	return result
+}
+
+
+func getPeaksHeightID(maxID uint64) (peaksHeightID map[uint64]uint64) {
+	peaks := FindPeak(maxID)
+	peaksHeightID = make(map[uint64]uint64)
+	//peaksHeightID:=make(map[uint64]uint64)
+	for _, id := range peaks {
+		peaksHeightID[GetHeightByID(id)] = id
+	}
+	return peaksHeightID
+}
+
+func (mmr *MMR) GenProofPath(BlockNums []uint64) (proofPath map[uint64][]byte) {
+	proofPath = make(map[uint64][]byte)
+	IDS := Find_mmr_ID_by_block_index(BlockNums).(map[uint64]uint64)
+	treeHeight := GetMMRTreeHeight(mmr.nodeNum)
+	peaksHeightId := getPeaksHeightID(mmr.nodeNum)
+	var path []uint64
+	for h := uint64(0); h <= treeHeight; h++ {
+		temp := make(map[uint64]uint64)
+		for _, id := range IDS {
+			broID := Find_bro_by_ID(id, mmr.nodeNum)
+			if broID <= 0 {
+				continue
+			}
+			_, flag := IDS[broID]
+			if flag == false {
+				if Find_bro_by_ID(broID, mmr.nodeNum) == 0 {
+					continue
+				} //是山峰，跳过，外层单独处理山峰
+				path = append(path, broID)
+			}
+			parID := Find_parent_by_ID(id, mmr.nodeNum)
+			temp[parID] = parID
+		}
+		//处理该层山峰节点
+		peakID, flag := peaksHeightId[h]
+		if flag == true {
+			_, flag := IDS[peakID]
+			if flag == false {
+				path = append(path, peakID)
+			}
+		}
+		IDS = temp
+	}
+	sort.Sort(array(path))
+	proofPath = mmr.GetHashByID(path)
+	return proofPath
+}
+
+func (mmr *MMR) CreatProofRoot(proofPath map[uint64][]byte, blockNumsHash map[uint64][]byte) (root []byte) {
+	IDsHash := make(map[uint64][]byte)
+	if blockNumsHash != nil {
+		IDsHash = Find_mmr_ID_by_block_index(blockNumsHash).(map[uint64][]byte)
+	}
+	peaksIDHash := make(map[uint64][]byte)
+	treeHeight := GetMMRTreeHeight(mmr.nodeNum)
+	peaksHeightId := getPeaksHeightID(mmr.nodeNum)
+	// 按层处理
+	for h := uint64(0); h <= treeHeight; h++ {
+		temp := make(map[uint64][]byte)
+		//处理一层
+		for k, v := range IDsHash {
+			bro := Find_bro_by_ID(k, mmr.nodeNum)
+			if bro != 0 {
+				broHash, flag := proofPath[bro]
+				if !flag {
+					broHash, flag = IDsHash[bro]
+				}
+				par := Find_parent_by_ID(k, mmr.nodeNum)
+				if k < bro {
+					temp[par] = hash256(v, broHash)
+				} else {
+					temp[par] = hash256(broHash, v)
+				}
+			} else {
+				//山峰
+				peaksIDHash[k] = v
+			}
+		}
+		//处理该层山峰节点
+		peakID, flag := peaksHeightId[h]
+		if flag { //该层有山峰
+			_, flag = IDsHash[peakID]
+			if flag == false { //山峰没有处理过
+				// 山峰的hashValue从proofPath获取
+				peakhash, flag := proofPath[peakID]
+				if flag {
+					peaksIDHash[peakID] = peakhash
+				}
+			}
+		}
+
+		// 处理上面一层
+		IDsHash = temp
+	}
+	root = bagPeaks(peaksIDHash)
+	return root
+}
+
+func bagPeaks(peaks map[uint64][]byte) []byte {
+	sortedid := itemSort(peaks)
+	i := len(sortedid) - 1
+	result := peaks[sortedid[i]]
+	for ; i >= 1; i-- {
+		left := sortedid[i-1]
+		result = hash256(peaks[left], result)
+	}
+	return result
+}
+
+////////////////////////////////////////////////////
+
+
 // NewBlock constructs a block with no data and no metadata.
 func NewBlock(seqNum uint64, previousHash []byte) *cb.Block {
 	block := &cb.Block{}
@@ -24,6 +655,22 @@
 	block.Header.Number = seqNum
 	block.Header.PreviousHash = previousHash
 	block.Header.DataHash = []byte{}
+	////////////////////////////////////////////////////
+	// added by fjyu@whu.edu.cn at 2022.09.22
+	if (seqNum == 0) {
+	      block.Header.MMRRoot = previousHash
+
+	      // 删除文件                     
+	      RemoveMMRDataBase("./test.db")
+        } else {
+		// 打开数据库           
+		mmr := OpenMMRDB("./test.db")
+		// 插入数据                    
+		bytestmp := mmr.NewNode(previousHash, seqNum - 1).([]byte)
+	        block.Header.MMRRoot = bytestmp
+		CloseMMRDB(&mmr)
+	}
+        ////////////////////////////////////////////////////
 	block.Data = &cb.BlockData{}
 
 	var metadataContents [][]byte
@@ -39,12 +686,20 @@
 	Number       *big.Int
 	PreviousHash []byte
 	DataHash     []byte
+	////////////////////////////////////////////////////
+	// added by fjyu@whu.edu.cn at 2022.09.14
+	MMRRoot      []byte
+        ////////////////////////////////////////////////////
 }
 
 func BlockHeaderBytes(b *cb.BlockHeader) []byte {
 	asn1Header := asn1Header{
 		PreviousHash: b.PreviousHash,
 		DataHash:     b.DataHash,
+	        ////////////////////////////////////////////////////
+	        // added by fjyu@whu.edu.cn at 2022.09.14
+		MMRRoot:      b.MMRRoot,
+	        ////////////////////////////////////////////////////
 		Number:       new(big.Int).SetUint64(b.Number),
 	}
 	result, err := asn1.Marshal(asn1Header)
diff -ru ./fabric/protoutil/blockutils_test.go ../fabric/protoutil/blockutils_test.go
--- ./fabric/protoutil/blockutils_test.go	2022-01-28 10:57:00.000000000 +0800
+++ ../fabric/protoutil/blockutils_test.go	2022-09-14 13:48:48.000000000 +0800
@@ -4,6 +4,13 @@
 SPDX-License-Identifier: Apache-2.0
 */
 
+
+////////////////////////////////////////////////////
+// modifications by fjyu@whu.edu.cn at 2022.09.14
+//    change all assert as require
+////////////////////////////////////////////////////
+
+
 package protoutil_test
 
 import (
@@ -13,11 +20,17 @@
 	"testing"
 
 	"github.com/golang/protobuf/proto"
-	"github.com/hyperledger/fabric-protos-go/common"
+	////////////////////////////////////////////////////
+	// commented by fjyu@whu.edu.cn at 2022.09.14
+	// "github.com/hyperledger/fabric-protos-go/common"
+	////////////////////////////////////////////////////
 	cb "github.com/hyperledger/fabric-protos-go/common"
 	configtxtest "github.com/hyperledger/fabric/common/configtx/test"
 	"github.com/hyperledger/fabric/protoutil"
-	"github.com/stretchr/testify/assert"
+	////////////////////////////////////////////////////
+	// commented by fjyu@whu.edu.cn at 2022.09.14
+	// "github.com/stretchr/testify/assert"
+	////////////////////////////////////////////////////
 	"github.com/stretchr/testify/require"
 )
 
@@ -25,32 +38,60 @@
 
 func TestNewBlock(t *testing.T) {
 	var block *cb.Block
-	assert.Nil(t, block.GetHeader())
-	assert.Nil(t, block.GetData())
-	assert.Nil(t, block.GetMetadata())
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.Nil(t, block.GetHeader())
+	// assert.Nil(t, block.GetData())
+	// assert.Nil(t, block.GetMetadata())
+	require.Nil(t, block.GetHeader())
+        require.Nil(t, block.GetData())
+        require.Nil(t, block.GetMetadata())
+
+	t.Log("test add mmrroot, hello world")
+	////////////////////////////////////////////////////
 
 	data := &cb.BlockData{
 		Data: [][]byte{{0, 1, 2}},
 	}
 	block = protoutil.NewBlock(uint64(0), []byte("datahash"))
-	assert.Equal(t, []byte("datahash"), block.Header.PreviousHash, "Incorrect previous hash")
-	assert.NotNil(t, block.GetData())
-	assert.NotNil(t, block.GetMetadata())
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.Equal(t, []byte("datahash"), block.Header.PreviousHash, "Incorrect previous hash")
+	// assert.NotNil(t, block.GetData())
+	// assert.NotNil(t, block.GetMetadata())
+	require.Equal(t, []byte("datahash"), block.Header.PreviousHash, "Incorrect previous hash")
+	require.NotNil(t, block.GetData())
+	require.NotNil(t, block.GetMetadata())
+	////////////////////////////////////////////////////
 	block.GetHeader().DataHash = protoutil.BlockDataHash(data)
 
 	asn1Bytes, err := asn1.Marshal(struct {
 		Number       int64
 		PreviousHash []byte
 		DataHash     []byte
+	        ////////////////////////////////////////////////////
+	        // added by fjyu@whu.edu.cn at 2022.09.14
+		MMRRoot      []byte
+	        ////////////////////////////////////////////////////
 	}{
 		Number:       0,
 		DataHash:     protoutil.BlockDataHash(data),
 		PreviousHash: []byte("datahash"),
+	        ////////////////////////////////////////////////////
+	        // added by fjyu@whu.edu.cn at 2022.09.14
+		MMRRoot:      []byte("aascdcdvfvfvfscsdc"),
+	        ////////////////////////////////////////////////////
 	})
 	headerHash := sha256.Sum256(asn1Bytes)
-	assert.NoError(t, err)
-	assert.Equal(t, asn1Bytes, protoutil.BlockHeaderBytes(block.Header), "Incorrect marshaled blockheader bytes")
-	assert.Equal(t, headerHash[:], protoutil.BlockHeaderHash(block.Header), "Incorrect blockheader hash")
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.NoError(t, err)
+	// assert.Equal(t, asn1Bytes, protoutil.BlockHeaderBytes(block.Header), "Incorrect marshaled blockheader bytes")
+	// assert.Equal(t, headerHash[:], protoutil.BlockHeaderHash(block.Header), "Incorrect blockheader hash")
+	require.NoError(t, err)
+	require.Equal(t, asn1Bytes, protoutil.BlockHeaderBytes(block.Header), "Incorrect marshaled blockheader bytes")
+	require.Equal(t, headerHash[:], protoutil.BlockHeaderHash(block.Header), "Incorrect blockheader hash")
+	////////////////////////////////////////////////////
 }
 
 func TestGoodBlockHeaderBytes(t *testing.T) {
@@ -58,6 +99,10 @@
 		Number:       1,
 		PreviousHash: []byte("foo"),
 		DataHash:     []byte("bar"),
+	        ////////////////////////////////////////////////////
+	        // added by fjyu@whu.edu.cn at 2022.09.14
+		MMRRoot:      []byte("aascdcdvfvfvfscsdc"),
+	        ////////////////////////////////////////////////////
 	}
 
 	_ = protoutil.BlockHeaderBytes(goodBlockHeader) // Should not panic
@@ -66,6 +111,10 @@
 		Number:       math.MaxUint64,
 		PreviousHash: []byte("foo"),
 		DataHash:     []byte("bar"),
+	        ////////////////////////////////////////////////////
+	        // added by fjyu@whu.edu.cn at 2022.09.14
+		MMRRoot:      []byte("aascdcdvfvfvfscsdc"),
+	        ////////////////////////////////////////////////////
 	}
 
 	_ = protoutil.BlockHeaderBytes(goodBlockHeaderMaxNumber) // Should not panic
@@ -73,39 +122,106 @@
 
 func TestGetChannelIDFromBlockBytes(t *testing.T) {
 	gb, err := configtxtest.MakeGenesisBlock(testChannelID)
-	assert.NoError(t, err, "Failed to create test configuration block")
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.NoError(t, err, "Failed to create test configuration block")
+	require.NoError(t, err, "Failed to create test configuration block")
+	////////////////////////////////////////////////////
 	bytes, err := proto.Marshal(gb)
-	assert.NoError(t, err)
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.NoError(t, err)
+	require.NoError(t, err)
+	////////////////////////////////////////////////////
 	cid, err := protoutil.GetChannelIDFromBlockBytes(bytes)
-	assert.NoError(t, err)
-	assert.Equal(t, testChannelID, cid, "Failed to return expected chain ID")
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.NoError(t, err)
+	// assert.Equal(t, testChannelID, cid, "Failed to return expected chain ID")
+	require.NoError(t, err)
+	require.Equal(t, testChannelID, cid, "Failed to return expected chain ID")
+	////////////////////////////////////////////////////
 
 	// bad block bytes
 	_, err = protoutil.GetChannelIDFromBlockBytes([]byte("bad block"))
-	assert.Error(t, err, "Expected error with malformed block bytes")
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.Error(t, err, "Expected error with malformed block bytes")
+	require.Error(t, err, "Expected error with malformed block bytes")
+	////////////////////////////////////////////////////
 }
 
 func TestGetChannelIDFromBlock(t *testing.T) {
 	var err error
-	var gb *common.Block
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// var gb *common.Block
+	var gb *cb.Block
+	////////////////////////////////////////////////////
 	var cid string
 
 	// nil block
 	_, err = protoutil.GetChannelIDFromBlock(gb)
-	assert.Error(t, err, "Expected error getting channel id from nil block")
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.Error(t, err, "Expected error getting channel id from nil block")
+	require.Error(t, err, "Expected error getting channel id from nil block")
+	////////////////////////////////////////////////////
 
 	gb, err = configtxtest.MakeGenesisBlock(testChannelID)
-	assert.NoError(t, err, "Failed to create test configuration block")
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.NoError(t, err, "Failed to create test configuration block")
+	require.NoError(t, err, "Failed to create test configuration block")
+	////////////////////////////////////////////////////
 
 	cid, err = protoutil.GetChannelIDFromBlock(gb)
-	assert.NoError(t, err, "Failed to get chain ID from block")
-	assert.Equal(t, testChannelID, cid, "Failed to return expected chain ID")
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.NoError(t, err, "Failed to get chain ID from block")
+	// assert.Equal(t, testChannelID, cid, "Failed to return expected chain ID")
+	require.NoError(t, err, "Failed to get chain ID from block")
+	require.Equal(t, testChannelID, cid, "Failed to return expected chain ID")
+	////////////////////////////////////////////////////
+
+	// missing data
+	badBlock := gb
+	badBlock.Data = nil
+	_, err = protoutil.GetChannelIDFromBlock(badBlock)
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.Error(t, err, "Expected error with missing block data")
+	require.Error(t, err, "Expected error with missing block data")
+	////////////////////////////////////////////////////
+
+	// no envelope
+	badBlock = &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{[]byte("bad envelope")},
+		},
+	}
+	_, err = protoutil.GetChannelIDFromBlock(badBlock)
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.Error(t, err, "Expected error with no envelope in data")
+	require.Error(t, err, "Expected error with no envelope in data")
+	////////////////////////////////////////////////////
+
+	// bad payload
+	env, _ := proto.Marshal(&cb.Envelope{
+		Payload: []byte("bad payload"),
+	})
+	badBlock = &cb.Block{
 
 	// missing data
 	badBlock := gb
 	badBlock.Data = nil
 	_, err = protoutil.GetChannelIDFromBlock(badBlock)
-	assert.Error(t, err, "Expected error with missing block data")
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.Error(t, err, "Expected error with missing block data")
+	require.Error(t, err, "Expected error with missing block data")
+	////////////////////////////////////////////////////
 
 	// no envelope
 	badBlock = &cb.Block{
@@ -114,7 +230,11 @@
 		},
 	}
 	_, err = protoutil.GetChannelIDFromBlock(badBlock)
-	assert.Error(t, err, "Expected error with no envelope in data")
+	////////////////////////////////////////////////////
+	// modified by fjyu@whu.edu.cn at 2022.09.14
+	// assert.Error(t, err, "Expected error with no envelope in data")
+	require.Error(t, err, "Expected error with no envelope in data")
+	////////////////////////////////////////////////////
 
 	// bad payload
 	env, _ := proto.Marshal(&cb.Envelope{
@@ -126,7 +246,7 @@
 		},
 	}
 	_, err = protoutil.GetChannelIDFromBlock(badBlock)
-	assert.Error(t, err, "Expected error - malformed payload")
+	require.Error(t, err, "Expected error - malformed payload")
 
 	// bad channel header
 	payload, _ := proto.Marshal(&cb.Payload{
@@ -143,7 +263,7 @@
 		},
 	}
 	_, err = protoutil.GetChannelIDFromBlock(badBlock)
-	assert.Error(t, err, "Expected error with malformed channel header")
+	require.Error(t, err, "Expected error with malformed channel header")
 
 	// nil payload header
 	payload, _ = proto.Marshal(&cb.Payload{})
@@ -156,54 +276,54 @@
 		},
 	}
 	_, err = protoutil.GetChannelIDFromBlock(badBlock)
-	assert.Error(t, err, "Expected error when payload header is nil")
+	require.Error(t, err, "Expected error when payload header is nil")
 }
 
 func TestGetBlockFromBlockBytes(t *testing.T) {
 	testChainID := "myuniquetestchainid"
 	gb, err := configtxtest.MakeGenesisBlock(testChainID)
-	assert.NoError(t, err, "Failed to create test configuration block")
+	require.NoError(t, err, "Failed to create test configuration block")
 	blockBytes, err := protoutil.Marshal(gb)
-	assert.NoError(t, err, "Failed to marshal block")
+	require.NoError(t, err, "Failed to marshal block")
 	_, err = protoutil.UnmarshalBlock(blockBytes)
-	assert.NoError(t, err, "to get block from block bytes")
+	require.NoError(t, err, "to get block from block bytes")
 
 	// bad block bytes
 	_, err = protoutil.UnmarshalBlock([]byte("bad block"))
-	assert.Error(t, err, "Expected error for malformed block bytes")
+	require.Error(t, err, "Expected error for malformed block bytes")
 }
 
 func TestGetMetadataFromBlock(t *testing.T) {
 	t.Run("new block", func(t *testing.T) {
 		block := protoutil.NewBlock(0, nil)
 		md, err := protoutil.GetMetadataFromBlock(block, cb.BlockMetadataIndex_ORDERER)
-		assert.NoError(t, err, "Unexpected error extracting metadata from new block")
-		assert.Nil(t, md.Value, "Expected metadata field value to be nil")
-		assert.Equal(t, 0, len(md.Value), "Expected length of metadata field value to be 0")
+		require.NoError(t, err, "Unexpected error extracting metadata from new block")
+		require.Nil(t, md.Value, "Expected metadata field value to be nil")
+		require.Equal(t, 0, len(md.Value), "Expected length of metadata field value to be 0")
 		md = protoutil.GetMetadataFromBlockOrPanic(block, cb.BlockMetadataIndex_ORDERER)
-		assert.NotNil(t, md, "Expected to get metadata from block")
+		require.NotNil(t, md, "Expected to get metadata from block")
 	})
 	t.Run("no metadata", func(t *testing.T) {
 		block := protoutil.NewBlock(0, nil)
 		block.Metadata = nil
 		_, err := protoutil.GetMetadataFromBlock(block, cb.BlockMetadataIndex_ORDERER)
-		assert.Error(t, err, "Expected error with nil metadata")
-		assert.Contains(t, err.Error(), "no metadata in block")
+		require.Error(t, err, "Expected error with nil metadata")
+		require.Contains(t, err.Error(), "no metadata in block")
 	})
 	t.Run("no metadata at index", func(t *testing.T) {
 		block := protoutil.NewBlock(0, nil)
 		block.Metadata.Metadata = [][]byte{{1, 2, 3}}
 		_, err := protoutil.GetMetadataFromBlock(block, cb.BlockMetadataIndex_LAST_CONFIG)
-		assert.Error(t, err, "Expected error with nil metadata")
-		assert.Contains(t, err.Error(), "no metadata at index")
+		require.Error(t, err, "Expected error with nil metadata")
+		require.Contains(t, err.Error(), "no metadata at index")
 	})
 	t.Run("malformed metadata", func(t *testing.T) {
 		block := protoutil.NewBlock(0, nil)
 		block.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER] = []byte("bad metadata")
 		_, err := protoutil.GetMetadataFromBlock(block, cb.BlockMetadataIndex_ORDERER)
-		assert.Error(t, err, "Expected error with malformed metadata")
-		assert.Contains(t, err.Error(), "error unmarshaling metadata at index [ORDERER]")
-		assert.Panics(t, func() {
+		require.Error(t, err, "Expected error with malformed metadata")
+		require.Contains(t, err.Error(), "error unmarshaling metadata at index [ORDERER]")
+		require.Panics(t, func() {
 			_ = protoutil.GetMetadataFromBlockOrPanic(block, cb.BlockMetadataIndex_ORDERER)
 		}, "Expected panic with malformed metadata")
 	})
@@ -281,7 +401,7 @@
 	block := &cb.Block{}
 	protoutil.InitBlockMetadata(block)
 	// should have 3 entries
-	assert.Equal(t, 5, len(block.Metadata.Metadata), "Expected block to have 5 metadata entries")
+	require.Equal(t, 5, len(block.Metadata.Metadata), "Expected block to have 5 metadata entries")
 
 	// block with a single entry
 	block = &cb.Block{
@@ -290,7 +410,7 @@
 	block.Metadata.Metadata = append(block.Metadata.Metadata, []byte{})
 	protoutil.InitBlockMetadata(block)
 	// should have 3 entries
-	assert.Equal(t, 5, len(block.Metadata.Metadata), "Expected block to have 5 metadata entries")
+	require.Equal(t, 5, len(block.Metadata.Metadata), "Expected block to have 5 metadata entries")
 }
 
 func TestCopyBlockMetadata(t *testing.T) {
@@ -304,9 +424,9 @@
 	protoutil.CopyBlockMetadata(srcBlock, dstBlock)
 
 	// check that the copy worked
-	assert.Equal(t, len(srcBlock.Metadata.Metadata), len(dstBlock.Metadata.Metadata),
+	require.Equal(t, len(srcBlock.Metadata.Metadata), len(dstBlock.Metadata.Metadata),
 		"Expected target block to have same number of metadata entries after copy")
-	assert.Equal(t, metadata, dstBlock.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER],
+	require.Equal(t, metadata, dstBlock.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER],
 		"Unexpected metadata from target block")
 }
 
@@ -321,24 +441,24 @@
 			}),
 		})
 		result, err := protoutil.GetLastConfigIndexFromBlock(block)
-		assert.NoError(t, err, "Unexpected error returning last config index")
-		assert.Equal(t, index, result, "Unexpected last config index returned from block")
+		require.NoError(t, err, "Unexpected error returning last config index")
+		require.Equal(t, index, result, "Unexpected last config index returned from block")
 		result = protoutil.GetLastConfigIndexFromBlockOrPanic(block)
-		assert.Equal(t, index, result, "Unexpected last config index returned from block")
+		require.Equal(t, index, result, "Unexpected last config index returned from block")
 	})
 
 	t.Run("block with malformed signatures", func(t *testing.T) {
 		block.Metadata.Metadata[cb.BlockMetadataIndex_SIGNATURES] = []byte("apple")
 		_, err := protoutil.GetLastConfigIndexFromBlock(block)
-		assert.Error(t, err)
-		assert.Contains(t, err.Error(), "failed to retrieve metadata: error unmarshaling metadata at index [SIGNATURES]")
+		require.Error(t, err)
+		require.Contains(t, err.Error(), "failed to retrieve metadata: error unmarshaling metadata at index [SIGNATURES]")
 	})
 
 	t.Run("block with malformed orderer block metadata", func(t *testing.T) {
 		block.Metadata.Metadata[cb.BlockMetadataIndex_SIGNATURES] = protoutil.MarshalOrPanic(&cb.Metadata{Value: []byte("banana")})
 		_, err := protoutil.GetLastConfigIndexFromBlock(block)
-		assert.Error(t, err)
-		assert.Contains(t, err.Error(), "failed to unmarshal orderer block metadata")
+		require.Error(t, err)
+		require.Contains(t, err.Error(), "failed to unmarshal orderer block metadata")
 	})
 
 	// TODO: FAB-15864 remove the tests below when we stop supporting upgrade from
@@ -351,17 +471,17 @@
 			}),
 		})
 		result, err := protoutil.GetLastConfigIndexFromBlock(block)
-		assert.NoError(t, err, "Unexpected error returning last config index")
-		assert.Equal(t, index, result, "Unexpected last config index returned from block")
+		require.NoError(t, err, "Unexpected error returning last config index")
+		require.Equal(t, index, result, "Unexpected last config index returned from block")
 		result = protoutil.GetLastConfigIndexFromBlockOrPanic(block)
-		assert.Equal(t, index, result, "Unexpected last config index returned from block")
+		require.Equal(t, index, result, "Unexpected last config index returned from block")
 	})
 
 	t.Run("malformed metadata", func(t *testing.T) {
 		block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = []byte("bad metadata")
 		_, err := protoutil.GetLastConfigIndexFromBlock(block)
-		assert.Error(t, err)
-		assert.Contains(t, err.Error(), "failed to retrieve metadata: error unmarshaling metadata at index [LAST_CONFIG]")
+		require.Error(t, err)
+		require.Contains(t, err.Error(), "failed to retrieve metadata: error unmarshaling metadata at index [LAST_CONFIG]")
 	})
 
 	t.Run("malformed last config", func(t *testing.T) {
@@ -369,9 +489,9 @@
 			Value: []byte("bad last config"),
 		})
 		_, err := protoutil.GetLastConfigIndexFromBlock(block)
-		assert.Error(t, err, "Expected error with malformed last config metadata")
-		assert.Contains(t, err.Error(), "error unmarshaling LastConfig")
-		assert.Panics(t, func() {
+		require.Error(t, err, "Expected error with malformed last config metadata")
+		require.Contains(t, err.Error(), "error unmarshaling LastConfig")
+		require.Panics(t, func() {
 			_ = protoutil.GetLastConfigIndexFromBlockOrPanic(block)
 		}, "Expected panic with malformed last config metadata")
 	})
diff -ru ./fabric/vendor/github.com/hyperledger/fabric-protos-go/common/common.pb.go ../fabric/vendor/github.com/hyperledger/fabric-protos-go/common/common.pb.go
--- ./fabric/vendor/github.com/hyperledger/fabric-protos-go/common/common.pb.go	2022-01-28 10:57:00.000000000 +0800
+++ ../fabric/vendor/github.com/hyperledger/fabric-protos-go/common/common.pb.go	2022-09-29 16:26:37.000000000 +0800
@@ -659,6 +659,7 @@
 	Number               uint64   `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
 	PreviousHash         []byte   `protobuf:"bytes,2,opt,name=previous_hash,json=previousHash,proto3" json:"previous_hash,omitempty"`
 	DataHash             []byte   `protobuf:"bytes,3,opt,name=data_hash,json=dataHash,proto3" json:"data_hash,omitempty"`
+	MMRRoot              []byte   `protobuf:"bytes,4,opt,name=mmr_root,json=mmrroot,proto3" json:"mmr_root,omitempty"`
 	XXX_NoUnkeyedLiteral struct{} `json:"-"`
 	XXX_unrecognized     []byte   `json:"-"`
 	XXX_sizecache        int32    `json:"-"`
@@ -709,6 +710,13 @@
 	}
 	return nil
 }
+
+func (m *BlockHeader) GetMMRRoot() []byte {
+	if m != nil {
+		return m.MMRRoot
+	}
+	return nil
+}
 
 type BlockData struct {
 	Data                 [][]byte `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
Only in ../fabric/vendor/github.com/mattn: go-sqlite3
diff -ru ./fabric/vendor/modules.txt ../fabric/vendor/modules.txt
--- ./fabric/vendor/modules.txt	2022-01-28 10:57:00.000000000 +0800
+++ ../fabric/vendor/modules.txt	2022-09-29 16:10:21.000000000 +0800
@@ -203,6 +203,9 @@
 # github.com/mattn/go-runewidth v0.0.4
 ## explicit
 github.com/mattn/go-runewidth
+# github.com/mattn/go-sqlite3 v1.14.15
+## explicit
+github.com/mattn/go-sqlite3
 # github.com/matttproud/golang_protobuf_extensions v1.0.1
 github.com/matttproud/golang_protobuf_extensions/pbutil
 # github.com/miekg/pkcs11 v1.0.3
